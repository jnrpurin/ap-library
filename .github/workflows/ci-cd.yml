name: CI/CD - Tests, Coverage, Build & Publish Docker

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  packages: write
  id-token: write

env:
  # ... (suas outras variÃ¡veis de ambiente)
  SOLUTION_PATH: ./library-management-app/backend/LibraryManagementApp.sln
  UNIT_TEST_PROJECT_PATH: ./library-management-app/backend/UnitTests/UnitTests.csproj
  BACKEND_CONTEXT: ./library-management-app/backend
  # ... (outras variÃ¡veis)
  DOTNET_VERSION: '9.0.x'
  # Nova variÃ¡vel para o diretÃ³rio base de resultados (onde o Coverlet salva por padrÃ£o no CI)
  TEST_OUTPUT_DIR: ${{ github.workspace }}/library-management-app/backend/UnitTests/bin/Release/net9.0/

jobs:
  test-and-coverage:
    name: Run Unit Tests & Generate Coverage Report
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore ${{ env.SOLUTION_PATH }}

      - name: Build solution
        run: dotnet build ${{ env.SOLUTION_PATH }} --configuration Release --no-restore
      
      # O mÃ©todo correto, usando o coletor XPlat Code Coverage (Coverlet Data Collector)
      - name: Run unit tests with coverage
        run: >
          dotnet test ./library-management-app/backend/UnitTests/UnitTests.csproj
          --configuration Release
          --no-build
          /p:CollectCoverage=true # Esta linha jÃ¡ era usada, mas a prÃ³xima Ã© a mais importante
          --collect:"XPlat Code Coverage" # MUITO IMPORTANTE: Garante o coletor de dados.
          /p:CoverletOutput=./library-management-app/backend/UnitTests/bin/Release/net9.0/coverage/
          /p:CoverletOutputFormat=cobertura
          /p:ExcludeByFile="**/Migrations/*"
          /p:Threshold=70

      - name: Set coverage path variables
        id: coverage_path
        run: |
          # ðŸ’¡ ATUALIZADO: O arquivo e o relatÃ³rio de cobertura estÃ£o na sub-pasta 'coverage/'
          echo "COBERTURA_FILE=${{ env.TEST_OUTPUT_DIR }}coverage/coverage.cobertura.xml" >> $GITHUB_ENV
          echo "REPORT_DIR=${{ env.TEST_OUTPUT_DIR }}coverage/CoverageReport" >> $GITHUB_ENV # << AJUSTADO
        
      - name: List coverage output (Debug)
        # Agora listamos a nova sub-pasta 'coverage/' para verificar se o arquivo existe.
        run: |
          echo "Listing files in: ${{ env.TEST_OUTPUT_DIR }}coverage/"
          ls -R ${{ env.TEST_OUTPUT_DIR }}coverage/ || echo "Directory listing failed or directory not created (expected if empty)" # << AJUSTADO

      - name: Install ReportGenerator
        run: dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: Create coverage report (HTML)
        # A nova variÃ¡vel COBERTURA_FILE aponta para o caminho exato e completo.
        run: >
          reportgenerator
          -reports:${{ env.COBERTURA_FILE }}
          -targetdir:${{ env.REPORT_DIR }}
          -reporttypes:Html
        env:
          PATH: $PATH:/home/runner/.dotnet/tools
          
      # 1. Publicar Resultados dos Testes no GitHub (TRX)
      - name: Upload test results (TRX)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: '**/TestResults/*.trx'
          if-no-files-found: warn

      # 2. Publicar RelatÃ³rio de Cobertura (HTML)
      - name: Upload coverage report (HTML)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: ${{ env.REPORT_DIR }}
          if-no-files-found: warn

---
  build-and-push:
    name: Build Docker images & Publish
    runs-on: ubuntu-latest
    needs: test-and-coverage
    concurrency:
      group: ci-cd-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          registry: docker.io
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build & push backend image
      - name: Build and push backend image
        uses: docker/build-push-action@v4
        with:
          context: ${{ env.BACKEND_CONTEXT }}
          file: ${{ env.BACKEND_DOCKERFILE }}
          push: ${{ github.ref == 'refs/heads/main' }}
          tags: >
            ${{ env.IMAGE_BACKEND }}:${{ github.sha }}
            ${{ env.IMAGE_BACKEND }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build & push frontend image
      - name: Build and push frontend image
        uses: docker/build-push-action@v4
        with:
          context: ${{ env.FRONTEND_CONTEXT }}
          file: ${{ env.FRONTEND_DOCKERFILE }}
          push: ${{ github.ref == 'refs/heads/main' }}
          tags: >
            ${{ env.IMAGE_FRONTEND }}:${{ github.sha }}
            ${{ env.IMAGE_FRONTEND }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max